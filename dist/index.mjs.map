{"version":3,"sources":["../src/utils/smol-padding.ts","../src/utils/leaf-actions.ts","../src/utils/hash.ts","../src/tree/build-tree.ts","../src/tree/generate-proof.ts","../src/tree/verify-merkle-proof.ts","../src/tree/index.ts","../src/utils/format-for-circom.ts","../src/utils/bytes-to-bits.ts","../src/utils/convert-proof-leaf-to-bits.ts","../src/index.ts"],"sourcesContent":["// Poseidon hash of some numbers, e.g 1 will yield a 31-byte string.\n// This function pads all leaves to 32 bytes before being used in the tree.\n// On the contract, it won't be an issue.\n// Pad up all leaves before calling new MiniMerkleTree and after every hash.\n// Leaves coming from the contract are already 32 byte padded.\nexport function smolPadding(str: string): string {\n    const lenRem = 64 - (str.length - 2);\n    const pad0 = \"0\".repeat(lenRem)\n    return `0x${pad0}${str.slice(2, str.length)}`\n}","import { smolPadding } from \"./smol-padding\";\n\nexport function sortLeavesInAscOrder(leaf1: string, leaf2: string): [string, string] {\n    return (leaf1 < leaf2)\n        ? [smolPadding(leaf1), smolPadding(leaf2)]\n        : [smolPadding(leaf2), smolPadding(leaf1)]\n}\n\nexport function concatLeaves(leaf1: string, leaf2: string): string {\n    return Buffer.concat([\n        Buffer.from(leaf1),\n        Buffer.from(leaf2.slice(2))\n    ]).toString();\n}\n\n// If leaf1 is less than leaf2, the dir should be 0, meaning it comes first.\n// Else, dir is 1, meaning it comes after. This will be needed for Circom.\nexport function getLeafDir(leaf1: string, leaf2: string) {\n    return leaf1 < leaf2 ? 0 : 1;\n}\n\nexport default function sortAndConcatLeaves(leaf1: string, leaf2: string): string {\n    const [firstLeaf, secondLeaf] = sortLeavesInAscOrder(leaf1, leaf2)\n    return concatLeaves(firstLeaf, secondLeaf)\n}","import { poseidon } from \"poseidon-hash\";\nimport { smolPadding } from \"./smol-padding\";\n\nexport function hash(leaves: string[]): string {\n    return smolPadding(`0x${poseidon(leaves).toString(16)}`)\n}","import { TreeInterface } from \"../../interfaces/tree\";\nimport { sortLeavesInAscOrder } from \"../utils/leaf-actions\";\nimport { hash } from \"../utils/hash\";\n\nexport function buildTree(leaves: string[]): TreeInterface {\n    if (leaves.length < 2) throw new Error(\"Tree must be built with at least 2 leaves!\")\n\n    // Start tree with all the leaves.\n    let tree = [leaves];\n    let length = leaves.length;\n\n    // All depths are stored in separate arrays.\n    // [[depth(n+1) or root], [depth(n)], ..., [depth0]].\n    // New leaves for new depths are recomputed based off of the\n    // previous ones.\n    while (length >= 2) {\n        let sortedLeaves: string[];\n        const hashedPairs: string[] = []\n\n        // When length == 2, which will eventually be so given\n        // the division applied at the end, it is the last two\n        // leaves to yield the root.\n        if (length == 2) {\n            sortedLeaves = sortLeavesInAscOrder(leaves[0], leaves[1]);\n            hashedPairs.push(hash(sortedLeaves));\n            tree.unshift(hashedPairs);\n            break;\n        }\n\n        // Iterate over the leaves in the array.\n        // length will always match leaves [ at depth].length;\n        // This loop runs in a way that if there's an extra leaf after\n        // grouping, it's not touched here.\n        for (let i = 0; i < length - 1; i += 2) {\n            sortedLeaves = sortLeavesInAscOrder(leaves[i], leaves[i + 1])\n            hashedPairs.push(hash(sortedLeaves));\n        }\n\n        // The leaf not touched in the loop as a result of the depth leaves being\n        // odd is simply moved to the next one.\n        if (length % 2 == 1) hashedPairs.push(leaves[length - 1])\n\n        // New leaf depths are stored in front.\n        tree.unshift(hashedPairs)\n        leaves = hashedPairs\n\n        length = Math.floor((length + 1) / 2)\n    }\n\n    const treeStructure: TreeInterface = {\n        tree,\n        root: tree[0][0],\n        depth: tree.length,\n    }\n\n    return treeStructure\n}","import Tree from \".\";\nimport { Proof } from \"../../interfaces/proof\";\nimport { getLeafDir, sortLeavesInAscOrder } from \"../utils/leaf-actions\";\nimport assert from \"node:assert/strict\"\nimport { hash } from \"../utils/hash\";\n\nexport function generateProofForLeaf(this: Tree, leaf: string): Proof {\n    const { tree } = this\n\n    let currentLeaf = leaf;\n    let treeWithoutRoot = tree.slice(1, tree.length)\n    let lenTreeWithNoRoot = treeWithoutRoot.length\n\n    // If the leaf we're looking for is at any point not in\n    if (treeWithoutRoot[lenTreeWithNoRoot - 1].indexOf(leaf) == -1) {\n        throw new Error(\"Leaf not in tree!\")\n    }\n\n    const proof: string[] = []\n    const directions: number[] = []\n\n    // Start from the last i.e. depth 0 leaves, iterate back.\n    for (let i = lenTreeWithNoRoot - 1; i >= 0; i--) {\n        const leavesAtDepth = treeWithoutRoot[i]\n        let siblingLeaf: string\n\n        // If the number of leaves at this depth is even, all can be paired\n        // with one another.\n        // Everyone has a pair, group normally.\n        // This returns the leaf pair for the current leaf at this depth\n        // and also returns the leaves that make up this pair.\n        if (leavesAtDepth.length % 2 == 0) {\n            siblingLeaf = getSiblingLeaf(leavesAtDepth, currentLeaf)\n        } else {\n            // Based on the algorithm of the three construction, lone leaves after\n            // grouping an odd number of leaves, e.g. 7 => [2, 2, 2, 1] are taken\n            // up until they can complete a depth, i.e. make it even. If the depth\n            // is odd current leaf is the last leaf in the depth, do nothing.\n            if (leavesAtDepth.indexOf(currentLeaf) == leavesAtDepth.length - 1)\n                continue\n            else {\n                // If it's not the last, then, I can comfortably group.\n                // I already know the depth has an odd number of leaves,\n                // whatever is between index 0 and length - 2 can be grouped.\n                siblingLeaf = getSiblingLeaf(leavesAtDepth, currentLeaf)\n            }\n        }\n\n        // Here, I get the direction of the leaves, it doesn't matter the order.\n        // 0 meaning that the current leaf will go in front, and 1 meaning that\n        // it goes behind. It's for the currentLeaf with respect to siblingLeaf.\n        directions.push(getLeafDir(siblingLeaf, currentLeaf))\n        proof.push(siblingLeaf)\n\n        // Get the next hash using the two leaves.\n        currentLeaf = hash(sortLeavesInAscOrder(currentLeaf, siblingLeaf));\n    }\n\n    // The number of leaves in the proof MUST be equal to the number of directions.\n    assert.equal(proof.length, directions.length)\n    return { proof, directions }\n}\n\nfunction getSiblingLeaf(leaves: string[], leaf: string) {\n    const indexOfLeaf = leaves.indexOf(leaf)\n\n    let leafSibling\n\n    // Leaf grouping is done in such a way: [0, 1], [2, 3].\n    // Even indexes have the next leaf as their sibling.\n    // Odd indexes have the previous leaf as their sibling.\n    if (indexOfLeaf % 2 == 0) leafSibling = leaves[indexOfLeaf + 1]\n    else leafSibling = leaves[indexOfLeaf - 1]\n\n    return leafSibling\n}","import { Proof } from \"../../interfaces/proof\";\nimport { sortLeavesInAscOrder } from \"../utils/leaf-actions\";\nimport { hash } from \"../utils/hash\";\n\nexport function verifyMerkleProof(root: string, leaf: string, merkleProof: Proof): boolean {\n    const { proof, directions } = merkleProof\n\n    let currentHash = leaf\n    proof.forEach(function (currentLeaf) {\n        currentHash = hash(sortLeavesInAscOrder(currentLeaf, currentHash))\n    })\n\n    return currentHash == root\n}","import { MerkleTreeInterface } from \"../../interfaces/merkle-tree\";\nimport { Proof } from \"../../interfaces/proof\";\nimport { buildTree } from \"./build-tree\";\nimport { generateProofForLeaf } from \"./generate-proof\";\nimport { verifyMerkleProof } from \"./verify-merkle-proof\";\n\nexport default class MiniMerkleTree implements MerkleTreeInterface {\n    tree: string[][]\n    root: string\n    depth: number\n\n    // Populate tree here.\n    public constructor(leaves: string[]) {\n        const { tree, root, depth } = buildTree(leaves)\n\n        this.tree = tree\n        this.root = root\n        this.depth = depth\n    }\n\n    public generateMerkleProof(leaf: string): Proof {\n        return generateProofForLeaf.call(this, leaf)\n    }\n\n    public verifyProof(leaf: string, proof: Proof): boolean {\n        return verifyMerkleProof(this.root, leaf, proof)\n    }\n\n    public getLeavesAtDepth(depth: number): string[] {\n        const len = this.tree.length\n        if (!len || len <= depth) return []\n        return this.tree[depth]\n    }\n}","import { encodeBytes32String } from \"ethers\";\nimport { CircomProof } from \"../../interfaces/circom-proof\";\nimport { Proof } from \"../../interfaces/proof\";\nimport { convertProofToBits } from \"./convert-proof-leaf-to-bits\";\n\nexport default function formatForCircom(proof: Proof): CircomProof {\n    if (proof.proof.length > 32) throw new Error(\"Proof length exceeds 32!\")\n    \n    const length = proof.directions.length\n    const lengthTo32 = 32 - length\n\n    const validBits: number[] = []\n    const proofBits: number[][] = []\n\n    proof.directions.forEach(function (_, index: number) {\n        proofBits.push(convertProofToBits(proof.proof[index]))\n        validBits.push(1)\n    })\n\n    for (let i = 0; i < lengthTo32; i++) {\n        proofBits.push(convertProofToBits(encodeBytes32String(\"\")))\n        proof.directions.push(0)\n        validBits.push(0)\n    }\n\n    const circomProof = {\n        proof: proofBits,\n        directions: proof.directions,\n        validBits\n    }\n\n    return circomProof\n}","export default function bytesToBits(b: Uint8Array<ArrayBuffer>) {\n    const bits = [];\n    for (let i = 0; i < b.length; i++) {\n        for (let j = 0; j < 8; j++) {\n            if ((Number(b[i]) & (1 << j)) > 0) {\n                bits.push(1);\n            } else {\n                bits.push(0);\n            }\n        }\n    }\n    return bits\n}","import bytesToBits from \"./bytes-to-bits\"\n\nexport function convertProofToBits(proof: string): number[] {\n    const hexProof = proof.slice(2, proof.length)\n    // For stuff computed with Poseidon hash (basically, everything here), \n    // when converting to bits, reverse the buffer.\n    const uint8Array = new Uint8Array(Buffer.from(hexProof, \"hex\").reverse())\n    return bytesToBits(uint8Array)\n}","import MiniMerkleTree from \"./tree\";\nimport sortAndConcatLeaves, { concatLeaves, sortLeavesInAscOrder } from \"./utils/leaf-actions\";\nimport formatForCircom from \"./utils/format-for-circom\";\nimport bytesToBits from \"./utils/bytes-to-bits\";\nimport { smolPadding } from \"./utils/smol-padding\";\nimport { convertProofToBits } from \"./utils/convert-proof-leaf-to-bits\";\n\nexport {\n    formatForCircom,\n    sortAndConcatLeaves,\n    concatLeaves,\n    sortLeavesInAscOrder,\n    bytesToBits,\n    smolPadding,\n    convertProofToBits\n}\n\nexport default MiniMerkleTree"],"mappings":"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","names":[]}