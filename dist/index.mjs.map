{"version":3,"sources":["../src/utils/smol-padding.ts","../src/utils/leaf-actions.ts","../src/utils/hash.ts","../src/tree/build-tree.ts","../src/tree/generate-proof.ts","../src/tree/verify-merkle-proof.ts","../src/tree/index.ts","../src/utils/format-for-circom.ts","../src/utils/bytes-to-bits.ts","../src/utils/convert-proof-leaf-to-bits.ts","../src/utils/standardize.ts","../src/utils/bits-to-num.ts","../src/utils/generate-random-number.ts","../src/utils/get-random-nullifier.ts","../src/contract-utils/generate-keys.ts","../src/utils/hexify.ts","../src/utils/make-even.ts","../src/contract-utils/extract-key-metadata.ts","../src/contract-utils/calculate-fee.ts","../src/contract-utils/max-withdrawal.ts","../src/utils/get-input-object.ts","../src/index.ts"],"sourcesContent":["/**\n * Poseidon hash of some numbers, e.g 1 will yield a 31-byte string.\n * This function pads all leaves to 32 bytes before being used in the tree.\n * On the contract, it won't be an issue.\n * Pad up all leaves before calling new MiniMerkleTree and after every hash.\n * Leaves coming from the contract are already 32 byte padded.\n * If the leaf is already complete, nothing happens.\n */\nexport function smolPadding(str: string): string {\n    if (str.length > 66) throw new Error(\"Expected a bytes32 string.\")\n    const lenRem = 64 - (str.length - 2);\n    const pad0 = \"0\".repeat(lenRem)\n    return `0x${pad0}${str.slice(2)}`\n}","import { smolPadding } from \"./smol-padding\";\n\nexport function sortLeavesInAscOrder(leaf1: string, leaf2: string): [string, string] {\n    return (leaf1 < leaf2)\n        ? [smolPadding(leaf1), smolPadding(leaf2)]\n        : [smolPadding(leaf2), smolPadding(leaf1)]\n}\n\nexport function concatLeaves(leaf1: string, leaf2: string): string {\n    return Buffer.concat([\n        Buffer.from(leaf1),\n        Buffer.from(leaf2.slice(2))\n    ]).toString();\n}\n\n// If leaf1 is less than leaf2, the dir should be 0, meaning it comes first.\n// Else, dir is 1, meaning it comes after. This will be needed for Circom and\n// Merkle Proof generation.\nexport function getLeafDir(leaf1: string, leaf2: string) {\n    return leaf1 < leaf2 ? 0 : 1;\n}\n\nexport default function sortAndConcatLeaves(leaf1: string, leaf2: string): string {\n    const [firstLeaf, secondLeaf] = sortLeavesInAscOrder(leaf1, leaf2)\n    return concatLeaves(firstLeaf, secondLeaf)\n}","import { poseidon } from \"poseidon-hash\";\nimport { smolPadding } from \"./smol-padding\";\n\nexport function hash(leaves: string[]): string {\n    return smolPadding(`0x${poseidon(leaves).toString(16)}`)\n}\n\nexport function hashNums(num: number[]): string {\n    return smolPadding(`0x${poseidon(num).toString(16)}`)\n}","import { TreeInterface } from \"../../interfaces/tree\";\nimport { sortLeavesInAscOrder } from \"../utils/leaf-actions\";\nimport { hash } from \"../utils/hash\";\n\nexport function buildTree(leaves: string[]): TreeInterface {\n    if (leaves.length < 2) throw new Error(\"Tree must be built with at least 2 leaves!\")\n\n    // Start tree with all the leaves.\n    let tree = [leaves];\n    let length = leaves.length;\n\n    // All depths are stored in separate arrays.\n    // [[depth(n+1) or root], [depth(n)], ..., [depth0]].\n    // New leaves for new depths are recomputed based off of the\n    // previous ones.\n    while (length >= 2) {\n        let sortedLeaves: string[];\n        const hashedPairs: string[] = []\n\n        // When length == 2, which will eventually be so given\n        // the division applied at the end, it is the last two\n        // leaves to yield the root.\n        if (length == 2) {\n            sortedLeaves = sortLeavesInAscOrder(leaves[0], leaves[1]);\n            hashedPairs.push(hash(sortedLeaves));\n            tree.unshift(hashedPairs);\n            break;\n        }\n\n        // Iterate over the leaves in the array.\n        // length will always match leaves [ at depth].length;\n        // This loop runs in a way that if there's an extra leaf after\n        // grouping, it's not touched here.\n        for (let i = 0; i < length - 1; i += 2) {\n            sortedLeaves = sortLeavesInAscOrder(leaves[i], leaves[i + 1])\n            hashedPairs.push(hash(sortedLeaves));\n        }\n\n        // The leaf not touched in the loop as a result of the depth leaves being\n        // odd is simply moved to the next one.\n        if (length % 2 == 1) hashedPairs.push(leaves[length - 1])\n\n        // New leaf depths are stored in front.\n        tree.unshift(hashedPairs)\n        leaves = hashedPairs\n\n        length = Math.floor((length + 1) / 2)\n    }\n\n    const treeStructure: TreeInterface = {\n        tree,\n        root: tree[0][0],\n        depth: tree.length,\n    }\n\n    return treeStructure\n}","import Tree from \".\";\nimport { Proof } from \"../../interfaces/proof\";\nimport { getLeafDir, sortLeavesInAscOrder } from \"../utils/leaf-actions\";\nimport assert from \"node:assert/strict\"\nimport { hash } from \"../utils/hash\";\n\nexport function generateProofForLeaf(this: Tree, leaf: string): Proof {\n    const { tree } = this\n\n    let currentLeaf = leaf;\n    let treeWithoutRoot = tree.slice(1)\n    let lenTreeWithNoRoot = treeWithoutRoot.length\n\n    // If the leaf we're looking for is at any point not in\n    if (treeWithoutRoot[lenTreeWithNoRoot - 1].indexOf(leaf) == -1) {\n        throw new Error(\"Leaf not in tree!\")\n    }\n\n    const proof: string[] = []\n    const directions: number[] = []\n\n    // Start from the last i.e. depth 0 leaves, iterate back.\n    for (let i = lenTreeWithNoRoot - 1; i >= 0; i--) {\n        const leavesAtDepth = treeWithoutRoot[i]\n        let siblingLeaf: string\n\n        // If the number of leaves at this depth is even, all can be paired\n        // with one another.\n        // Everyone has a pair, group normally.\n        // This returns the leaf pair for the current leaf at this depth\n        // and also returns the leaves that make up this pair.\n        if (leavesAtDepth.length % 2 == 0) {\n            siblingLeaf = getSiblingLeaf(leavesAtDepth, currentLeaf)\n        } else {\n            // Based on the algorithm of the three construction, lone leaves after\n            // grouping an odd number of leaves, e.g. 7 => [2, 2, 2, 1] are taken\n            // up until they can complete a depth, i.e. make it even. If the depth\n            // is odd current leaf is the last leaf in the depth, do nothing.\n            if (leavesAtDepth.indexOf(currentLeaf) == leavesAtDepth.length - 1)\n                continue\n            else {\n                // If it's not the last, then, I can comfortably group.\n                // I already know the depth has an odd number of leaves,\n                // whatever is between index 0 and length - 2 can be grouped.\n                siblingLeaf = getSiblingLeaf(leavesAtDepth, currentLeaf)\n            }\n        }\n\n        // Here, I get the direction of the leaves, it doesn't matter the order.\n        // 0 meaning that the current leaf will go in front, and 1 meaning that\n        // it goes behind. It's for the currentLeaf with respect to siblingLeaf.\n        directions.push(getLeafDir(currentLeaf, siblingLeaf))\n        proof.push(siblingLeaf)\n\n        // Get the next hash using the two leaves.\n        currentLeaf = hash(sortLeavesInAscOrder(currentLeaf, siblingLeaf));\n    }\n\n    // The number of leaves in the proof MUST be equal to the number of directions.\n    assert.equal(proof.length, directions.length)\n    return { proof, directions }\n}\n\nfunction getSiblingLeaf(leaves: string[], leaf: string) {\n    const indexOfLeaf = leaves.indexOf(leaf)\n\n    let leafSibling\n\n    // Leaf grouping is done in such a way: [0, 1], [2, 3].\n    // Even indexes have the next leaf as their sibling.\n    // Odd indexes have the previous leaf as their sibling.\n    if (indexOfLeaf % 2 == 0) leafSibling = leaves[indexOfLeaf + 1]\n    else leafSibling = leaves[indexOfLeaf - 1]\n\n    return leafSibling\n}","import { Proof } from \"../../interfaces/proof\";\nimport { hash } from \"../utils/hash\";\n\nexport function verifyMerkleProof(root: string, leaf: string, merkleProof: Proof): boolean {\n    const { proof, directions } = merkleProof\n    \n    let currentLeaf = leaf\n    proof.forEach(function (sibling, i) {\n        // if (1) hash(sibling, currentLeaf)\n        // if (0) hash(currentLeaf, sibling)\n        if (directions[i]) {\n            currentLeaf = hash([sibling, currentLeaf])\n        } else currentLeaf = hash([currentLeaf, sibling])\n    })\n\n    return currentLeaf == root\n}","import { MerkleTreeInterface } from \"../../interfaces/merkle-tree\";\nimport { Proof } from \"../../interfaces/proof\";\nimport { buildTree } from \"./build-tree\";\nimport { generateProofForLeaf } from \"./generate-proof\";\nimport { verifyMerkleProof } from \"./verify-merkle-proof\";\n\nexport default class MiniMerkleTree implements MerkleTreeInterface {\n    tree: string[][]\n    root: string\n    depth: number\n\n    public constructor(leaves: string[]) {\n        const { tree, root, depth } = buildTree(leaves)\n\n        this.tree = tree\n        this.root = root\n        this.depth = depth\n    }\n\n    public generateMerkleProof(leaf: string): Proof {\n        return generateProofForLeaf.call(this, leaf)\n    }\n\n    public verifyProof(leaf: string, proof: Proof): boolean {\n        return verifyMerkleProof(this.root, leaf, proof)\n    }\n\n    public getLeavesAtDepth(depth: number): string[] {\n        const len = this.tree.length\n        if (!len || len <= depth) return []\n        return this.tree[depth]\n    }\n}","import { encodeBytes32String } from \"ethers\";\nimport { CircomProof } from \"../../interfaces/circom-proof\";\nimport { Proof } from \"../../interfaces/proof\";\nimport { convertProofToBits } from \"./convert-proof-leaf-to-bits\";\n\n// Formats a given proof data into valid Circom input format, i.e., bits.\nexport default function formatForCircom(proof: Proof): CircomProof {\n    if (proof.proof.length > 32) throw new Error(\"Proof length exceeds 32!\")\n    \n    const length = proof.directions.length\n    const lengthTo32 = 32 - length\n\n    const validBits: number[] = []\n    const proofBits: number[][] = []\n\n    proof.directions.forEach(function (_, index: number) {\n        proofBits.push(convertProofToBits(proof.proof[index]))\n        validBits.push(1)\n    })\n\n    for (let i = 0; i < lengthTo32; i++) {\n        proofBits.push(convertProofToBits(encodeBytes32String(\"\")))\n        proof.directions.push(0)\n        validBits.push(0)\n    }\n\n    const circomProof = {\n        proof: proofBits,\n        directions: proof.directions,\n        validBits\n    }\n\n    return circomProof\n}","// Converts the bytes in a Uint8Array to the equivalent bits array.\nexport default function bytesToBits(bytes: Uint8Array<ArrayBuffer>): number[] {\n    const bits: number[] = [];\n\n    bytes.forEach(function (byte: number) {\n        for (let i = 0; i < 8; i++) {\n            if ((Number(byte) & (1 << i)) > 0) {\n                bits.push(1);\n            } else {\n                bits.push(0);\n            }\n        }\n    })\n    \n    return bits\n}","import bytesToBits from \"./bytes-to-bits\"\n\n// Converts a given 32-byte hex string to bits.\nexport function convertProofToBits(proof: string): number[] {\n    const hexProof = proof.slice(2)\n    // For stuff computed with Poseidon hash (basically, everything here), \n    // when converting to bits, reverse the buffer.\n    const uint8Array = new Uint8Array(Buffer.from(hexProof, \"hex\").reverse())\n    return bytesToBits(uint8Array)\n}","import { F1Field } from \"@zk2/ffjavascript\";\nimport { keccak256 } from \"ethers\";\nimport bytesToBits from \"./bytes-to-bits\";\nimport { smolPadding } from \"./smol-padding\";\nimport { bitsToNum } from \"./bits-to-num\";\n\n// Circom standard prime, used for Poseidon hash and Finite Field calculations.\n// Reference: https://docs.circom.io/circom-language/basic-operators/\nexport const PRIME = 21888242871839275222246405745257275088548364400416034343698204186575808495617n\n\n/**\n * Converts the hash of a given string, usually hex to it's Poseidon field number\n * equivalent. Some hex strings are too large that their hashes cannot fit within\n * the valid field, and this causes bugs when computing merkle trees in Circom.\n * \n * Ideally, the use case of this function is not in the merkle tree, leaves coming\n * in are already standardized from the contract. However, when computing\n * the deposit key, this function will be used to properly calculate the Poseidon\n * equivalent of a given deposit key (str). The equivalent is used as the deposit\n * commitment on the smart contract.\n */\nexport function standardizeToPoseidon(str: string, reverse: boolean = false): string {\n    const hash = keccak256(str)\n    const hashBits = reverse ? bytesToBits(new Uint8Array(Buffer.from(hash.slice(2), \"hex\").reverse()))\n        : bytesToBits(new Uint8Array(Buffer.from(hash.slice(2), \"hex\")))\n    const reduced = new F1Field(PRIME).e(bitsToNum(hashBits))\n    return smolPadding(`0x${reduced.toString(16)}`)\n}","// Converts a given set of bits (0, 1) in an array to the \n// number equivalent.\n// This follows the LSB ordering.\nexport function bitsToNum(bits: number[]): BigInt {\n    let total = 0n;\n\n    bits.forEach(function (bit: number, index: number) {\n        total += BigInt(bit) * (2n ** BigInt(index)); \n    })\n\n    return total\n}","import { strToHex } from \"hexyjs\"\nimport Randomstring from \"randomstring\"\nimport prand from \"pure-rand\"\nimport { PRIME } from \"./standardize\"\n\nconst LOWER_LIMIT = 1_000_000_000_000_000n\nconst UPPER_LIMIT = PRIME - BigInt(1e9)\n\nexport function generateRandomNumber(): BigInt {\n    const randomString = Randomstring.generate({\n        length: 8,\n        charset: [\"alphanumeric\"]\n    })\n\n    const seed = Number(`0x${strToHex(randomString)}`)\n\n    const rng = prand.xoroshiro128plus(seed)\n    const randomNumber = prand.unsafeUniformBigIntDistribution(LOWER_LIMIT, UPPER_LIMIT, rng)\n\n    return randomNumber\n}","import { strToHex } from \"hexyjs\"\nimport Randomstring from \"randomstring\"\nimport prand from \"pure-rand\"\n\nconst LOWER_LIMIT = 1\nconst UPPER_LIMIT = Number.MAX_SAFE_INTEGER\n\nexport function getRandomNullifier(): number {\n    const randomString = Randomstring.generate({\n        length: 8,\n        charset: [\"alphanumeric\"]\n    })\n\n    const seed = Number(`0x${strToHex(randomString)}`)\n\n    const rng = prand.xoroshiro128plus(seed)\n    const nullifier = prand.unsafeUniformIntDistribution(LOWER_LIMIT, UPPER_LIMIT, rng)\n\n    return nullifier\n}","import { keccak256 } from \"ethers\";\nimport { Keys } from \"../../interfaces/keys\";\nimport { generateRandomNumber } from \"../utils/generate-random-number\";\nimport { smolPadding } from \"../utils/smol-padding\";\nimport { hexify } from \"../utils/hexify\";\nimport { strToHex } from \"hexyjs\";\nimport { makeEven } from \"../utils/make-even\";\nimport { extractKeyMetadata } from \"./extract-key-metadata\";\n\nexport function generatekeys(asset: string, amount: BigInt, secretKey: string): Keys {\n    const withdrawalKey = generateWithdrawalKey(asset, amount, secretKey)\n    const depositKey = generateDepositKey(withdrawalKey, secretKey)\n\n    return { withdrawalKey, depositKey }\n}\n\nfunction generateWithdrawalKey(asset: string, amount: BigInt, secretKey: string): string {\n    const entropy = makeEven(generateRandomNumber().toString(16))\n    const hexSecretKey = strToHex(secretKey)\n\n    const withdrawalKeyHash = keccak256(`${hexify(entropy)}${hexSecretKey}`)\n\n    const withdrawalKey = `${withdrawalKeyHash}${_encodePackAsset(asset)}${_encodePackAmount(amount)}`\n    return withdrawalKey\n}\n\nexport function generateDepositKey(withdrawalKey: string, secretKey: string): string {\n    const { asset, amount } = extractKeyMetadata(withdrawalKey)\n    const hexSecretKey = strToHex(secretKey)\n    const withdrawalKeyConcat = `${withdrawalKey}${hexSecretKey}`\n    const depositKeyHash = keccak256(withdrawalKeyConcat)\n\n    const depositKey = `${depositKeyHash}${_encodePackAsset(asset)}${_encodePackAmount(amount)}`\n    return depositKey\n}\n\nfunction _encodePackAsset(asset: string): string {\n    return asset.slice(2)\n}\n\nfunction _encodePackAmount(amount: BigInt): string {\n    const hexAmount = hexify(amount.toString(16))\n    const encodePackAmount = smolPadding(hexAmount).slice(2)\n    return encodePackAmount\n}","export function hexify(str: string): string {\n    return `0x${str}`\n}","export function makeEven(str: string): string {\n    return (str.length % 2 == 1) ? `0${str}` : str\n}","import { KeyMetadata } from \"../../interfaces/key-metadata\";\n\n/// 84 byte key, 168 characters.\n/// 170 characters, including 0x, which is added in TS.\n/// 0 - 65 : Key Hash, 32 bytes, including 0x.\n/// 66 - 105 : Address, 20 bytes.\n/// 106 - end : Amount, 32 bytes.\n\nexport function extractKeyMetadata(key: string): KeyMetadata {\n    // Including 0x, bytes32 stretches to 66 characters.\n    const keyHash = key.slice(0, 66)\n    const asset = `0x${key.slice(66, 106)}`\n    const amount = BigInt(`0x${key.slice(106)}`)\n\n    return { keyHash, asset, amount }\n}","export function calculateFee(amount: BigInt): BigInt {\n    const division = BigInt(amount.toString()) / 100n\n    const quotient = division.toString().split(\".\")[0]\n    return BigInt(quotient)\n}","import { calculateFee } from \"./calculate-fee\";\nimport { extractKeyMetadata } from \"./extract-key-metadata\";\n\nexport function getMaxWithdrawalOnKey(key: string): BigInt {\n    const { amount } = extractKeyMetadata(key)\n    return getMaxWithdrawalOnAmount(amount)\n}\n\nexport function getMaxWithdrawalOnAmount(amount: BigInt): BigInt {\n    const fee = calculateFee(amount)\n    return BigInt(amount.toString()) - BigInt(fee.toString())\n}","import { MerkleTreeInterface } from \"../../interfaces/merkle-tree\";\nimport { strToHex } from \"hexyjs\";\nimport { convertProofToBits } from \"./convert-proof-leaf-to-bits\";\nimport formatForCircom from \"./format-for-circom\";\nimport bytesToBits from \"./bytes-to-bits\";\nimport { getRandomNullifier } from \"./get-random-nullifier\";\nimport { hashNums } from \"./hash\";\nimport { CircomInputObject } from \"../../interfaces/circom-input-object\";\n\nexport function getInputObjects(\n    withdrawalKey: string,\n    standardizedKey: string,\n    secretKey: string,\n    tree: MerkleTreeInterface\n): CircomInputObject {\n    const root = convertProofToBits(tree.root)\n    const merkleProof = tree.generateMerkleProof(standardizedKey)\n    const { proof, directions, validBits } = formatForCircom(merkleProof)\n\n    const withdrawalKeyBits = bytesToBits(new Uint8Array(Buffer.from(withdrawalKey.slice(2), \"hex\")))\n    const secretKeyBits = bytesToBits(new Uint8Array(Buffer.from(strToHex(secretKey), \"hex\")))\n    \n    const nullifier = getRandomNullifier()\n    const nullHash = hashNums([nullifier])\n    const nullifierHash = convertProofToBits(nullHash)\n\n    return {\n        root,\n        withdrawalKey: withdrawalKeyBits,\n        secretKey: secretKeyBits,\n        directions,\n        validBits,\n        proof,\n        nullifier,\n        nullifierHash\n    }\n}","import MiniMerkleTree from \"./tree\";\nimport sortAndConcatLeaves, { concatLeaves, sortLeavesInAscOrder } from \"./utils/leaf-actions\";\nimport formatForCircom from \"./utils/format-for-circom\";\nimport bytesToBits from \"./utils/bytes-to-bits\";\nimport { smolPadding } from \"./utils/smol-padding\";\nimport { convertProofToBits } from \"./utils/convert-proof-leaf-to-bits\";\nimport { PRIME, standardizeToPoseidon } from \"./utils/standardize\";\nimport { bitsToNum } from \"./utils/bits-to-num\";\nimport { generateRandomNumber } from \"./utils/generate-random-number\";\nimport { getRandomNullifier } from \"./utils/get-random-nullifier\";\nimport { hashNums } from \"./utils/hash\";\nimport { generatekeys, generateDepositKey } from \"./contract-utils/generate-keys\";\nimport { getMaxWithdrawalOnKey, getMaxWithdrawalOnAmount } from \"./contract-utils/max-withdrawal\";\nimport { getInputObjects } from \"./utils/get-input-object\";\nimport { CircomProof } from \"../interfaces/circom-proof\";\nimport { KeyMetadata } from \"../interfaces/key-metadata\";\nimport { Keys } from \"../interfaces/keys\";\nimport { MerkleTreeInterface } from \"../interfaces/merkle-tree\";\nimport { Proof } from \"../interfaces/proof\";\nimport { TreeInterface } from \"../interfaces/tree\";\nimport { CircomInputObject } from \"../interfaces/circom-input-object\";\n\nexport {\n    PRIME,\n    bitsToNum,\n    bytesToBits,\n    concatLeaves,\n    convertProofToBits,\n    formatForCircom,\n    generateDepositKey,\n    generatekeys,\n    generateRandomNumber,\n    getInputObjects,\n    getMaxWithdrawalOnAmount,\n    getMaxWithdrawalOnKey,\n    getRandomNullifier,\n    hashNums,\n    smolPadding,\n    sortAndConcatLeaves,\n    sortLeavesInAscOrder,\n    standardizeToPoseidon,\n    CircomInputObject,\n    CircomProof,\n    KeyMetadata,\n    Keys,\n    MerkleTreeInterface,\n    Proof,\n    TreeInterface\n}\n\nexport default MiniMerkleTree"],"mappings":"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","names":["hash","strToHex","Randomstring","prand","LOWER_LIMIT","UPPER_LIMIT","keccak256","strToHex","strToHex","keccak256","strToHex","strToHex"]}